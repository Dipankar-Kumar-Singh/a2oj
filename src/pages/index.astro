---
import Layout from '../layouts/Layout.astro';
import Settings from '../components/Settings.astro';
import quotes from '../data/quotes.json';

const ladders = [
	{
		id: 11,
		name: 'Rating < 1300',
		description: 'For beginners, unrated users or users with Codeforces Rating < 1300',
		count: 100,
		color: 'teal',
		difficulty: 'Beginner'
	},
	{
		id: 12,
		name: '1300 ≤ Rating ≤ 1399',
		description: 'Build fundamentals with problems at the easy-medium level',
		count: 100,
		color: 'cyan',
		difficulty: 'Easy'
	},
	{
		id: 13,
		name: '1400 ≤ Rating ≤ 1499',
		description: 'Strengthen problem-solving with moderate difficulty',
		count: 100,
		color: 'sky',
		difficulty: 'Medium'
	},
	{
		id: 14,
		name: '1500 ≤ Rating ≤ 1599',
		description: 'Challenging problems for intermediate competitors',
		count: 100,
		color: 'amber',
		difficulty: 'Medium-Hard'
	},
	{
		id: 15,
		name: '1600 ≤ Rating ≤ 1699',
		description: 'Advanced problem-solving techniques required',
		count: 100,
		color: 'orange',
		difficulty: 'Hard'
	},
	{
		id: 16,
		name: '1700 ≤ Rating ≤ 1799',
		description: 'For experienced competitors seeking mastery',
		count: 100,
		color: 'rose',
		difficulty: 'Very Hard'
	},
	{
		id: 17,
		name: '1800 ≤ Rating ≤ 1899',
		description: 'Expert-level problems with advanced algorithms',
		count: 100,
		color: 'red',
		difficulty: 'Expert'
	},
	{
		id: 18,
		name: '1900 ≤ Rating ≤ 1999',
		description: 'Master-level problems requiring deep insight',
		count: 100,
		color: 'fuchsia',
		difficulty: 'Master'
	},
];

const divisionLadders = [
	{
		id: 4,
		name: 'Div. 2, Problem A',
		description: 'Classic Div. 2 A problems to build speed',
		count: 100,
		division: 'Division 2'
	},
	{
		id: 5,
		name: 'Div. 2, Problem B',
		description: 'Implementation and observation problems',
		count: 100,
		division: 'Division 2'
	},
	{
		id: 6,
		name: 'Div. 2, Problem C',
		description: 'Algorithmic thinking and optimization',
		count: 100,
		division: 'Division 2'
	},
	{
		id: 7,
		name: 'Div. 2, Problem D',
		description: 'Advanced data structures and algorithms',
		count: 100,
		division: 'Division 2'
	},
];
---

<Layout title="A2OJ Refreshed - Practice Ladders">
	<main class="min-h-screen full-page-grid">
		<!-- Hero Section with Quote and Controls -->
		<div class="engineering-hero-compact relative">
			<div class="relative z-10 max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
				
				<!-- Rotating Quote Section -->
				<div class="quote-container" id="quote-container">
					<blockquote class="quote-text" id="quote-text">
						"{quotes[0].quote}"
					</blockquote>
					<div class="quote-attribution">
						<span class="quote-author" id="quote-author">— {quotes[0].author}</span>
						<a 
							href={quotes[0].source_url} 
							target="_blank" 
							rel="noopener noreferrer" 
							class="quote-source-link"
							id="quote-source-link"
							title="View source"
						>
							<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
							</svg>
						</a>
					</div>
				</div>

				<!-- Header Row: Project Label + User Input -->
				<div class="flex flex-col sm:flex-row items-center justify-between gap-4 mt-6">
					<!-- Project Label -->
					<div class="engineering-hero-label">
						<span class="engineering-hero-label-text">PROJECT // A2OJ.REFRESHED</span>
					</div>
					
					<!-- User Handle Input -->
					<div class="flex items-end gap-3">
						<div class="engineering-hero-input-box-compact">
							<span class="engineering-input-label">USER.HANDLE</span>
							<input 
								type="text" 
								id="cf-handle-input"
								placeholder="Enter your Codeforces handle"
								class="engineering-input-compact"
							/>
						</div>
						<button id="track-button" class="engineering-button-compact">
							<span class="engineering-button-icon">▶</span>
							Track
						</button>
						<!-- Sync Status (shows when user is tracked) -->
						<div id="sync-status" class="hidden items-end gap-2">
							<button id="sync-button" class="engineering-sync-button" title="Refresh progress from Codeforces">
								<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
								</svg>
							</button>
							<span id="last-sync" class="engineering-sync-time"></span>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Rating-Based Ladders -->
		<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16 relative">
			<div class="mb-12">
				<div class="section-header">
					<div class="section-header-line"></div>
					<div class="section-header-box">
						<span class="section-header-label">SECTION 01</span>
						<h2 class="section-header-title">Rating-Based Ladders</h2>
					</div>
					<div class="section-header-line flex-1"></div>
					<div class="section-header-corner"></div>
				</div>
			</div>

			<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
				{ladders.map((ladder, index) => (
					<a href={`/ladder/${ladder.id}`} class="block card-hover">
						<div class="engineering-card">
							<div class="engineering-card-corner engineering-card-corner-tl"></div>
							<div class="engineering-card-corner engineering-card-corner-tr"></div>
							<div class="engineering-card-corner engineering-card-corner-bl"></div>
							<div class="engineering-card-corner engineering-card-corner-br"></div>
							
							<div class="flex justify-between items-start mb-4">
								<div class="flex-1">
									<span class="engineering-card-label">LADDER {String(index + 1).padStart(2, '0')}</span>
									<h3 class="engineering-card-title">
										{ladder.name}
									</h3>
								</div>
								<div class="text-right">
									<div class="engineering-card-count text-teal-600 dark:text-teal-400">
										{ladder.count}
									</div>
									<div class="engineering-card-unit">problems</div>
								</div>
							</div>
							
							<div class="engineering-card-divider"></div>
							
							<div class="flex items-center justify-between mt-4">
								<span class="engineering-card-badge">{ladder.difficulty}</span>
								<div class="flex items-center gap-2">
									<div class="w-24 bg-slate-200 dark:bg-slate-700 h-1">
										<div class="bg-teal-500 h-1" style="width: 0%"></div>
									</div>
									<span class="engineering-card-percent">0%</span>
								</div>
							</div>
						</div>
					</a>
				))}
			</div>
		</div>

		<!-- Division-Based Ladders -->
		<div class="py-16 relative">
			<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
				<div class="mb-12">
					<div class="section-header">
						<div class="section-header-line"></div>
						<div class="section-header-box">
							<span class="section-header-label">SECTION 02</span>
							<h2 class="section-header-title">Division-Based Ladders</h2>
						</div>
						<div class="section-header-line flex-1"></div>
						<div class="section-header-corner"></div>
					</div>
				</div>

				<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
					{divisionLadders.map((ladder, index) => (
						<a href={`/ladder/${ladder.id}`} class="block card-hover">
							<div class="engineering-card engineering-card-amber">
								<div class="engineering-card-corner engineering-card-corner-tl"></div>
								<div class="engineering-card-corner engineering-card-corner-tr"></div>
								<div class="engineering-card-corner engineering-card-corner-bl"></div>
								<div class="engineering-card-corner engineering-card-corner-br"></div>
								
								<span class="engineering-card-label">{ladder.division.toUpperCase()}</span>
								<h3 class="engineering-card-title text-lg">
									{ladder.name}
								</h3>
								
								<div class="engineering-card-divider mt-3"></div>
								
								<div class="flex justify-between items-center mt-3">
									<span class="engineering-card-badge engineering-card-badge-amber">Problem {String.fromCharCode(65 + index)}</span>
									<div class="text-right">
										<div class="engineering-card-count text-amber-600 dark:text-amber-400">
											{ladder.count}
										</div>
										<div class="engineering-card-unit">problems</div>
									</div>
								</div>
							</div>
						</a>
					))}
				</div>
			</div>
		</div>

		<!-- Footer -->
		<footer class="bg-slate-900 text-white py-12">
			<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
				<div class="text-center">
					<h3 class="text-2xl font-bold mb-4">A2OJ Refreshed</h3>
					<p class="text-slate-400 mb-6">
						Built with ❤️ for the competitive programming community
					</p>
					<div class="flex justify-center gap-6 text-sm text-slate-400">
						<a href="#" class="hover:text-white transition-colors">About</a>
						<a href="#" class="hover:text-white transition-colors">GitHub</a>
						<a href="#" class="hover:text-white transition-colors">API</a>
						<a href="#" class="hover:text-white transition-colors">Contact</a>
					</div>
				</div>
			</div>
		</footer>
	</main>

	<!-- Settings Component -->
	<Settings />
</Layout>

<!-- Quotes Data for Client-Side Rotation -->
<script type="application/json" id="quotes-data" set:html={JSON.stringify(quotes)}></script>

<script>
	// Quote Rotation System
	interface Quote {
		quote: string;
		author: string;
		context: string;
		source_url: string;
	}

	class QuoteRotator {
		private quotes: Quote[] = [];
		private currentIndex: number = 0;
		private rotationInterval: number | null = null;
		private readonly ROTATION_INTERVAL_MS = 30000; // 30 seconds
		private readonly STORAGE_KEY = 'quote_rotation_state';

		constructor() {
			this.loadQuotes();
			this.loadState();
			this.displayCurrentQuote();
			this.startRotation();
		}

		private loadQuotes(): void {
			const quotesData = document.getElementById('quotes-data');
			if (quotesData) {
				try {
					this.quotes = JSON.parse(quotesData.textContent || '[]');
				} catch (e) {
					console.error('Failed to parse quotes data:', e);
				}
			}
		}

		private loadState(): void {
			const savedState = localStorage.getItem(this.STORAGE_KEY);
			if (savedState) {
				try {
					const state = JSON.parse(savedState);
					// Check if we should advance based on time elapsed
					const now = Date.now();
					const elapsed = now - (state.lastUpdate || 0);
					const intervalsPassed = Math.floor(elapsed / this.ROTATION_INTERVAL_MS);
					
					if (intervalsPassed > 0 && this.quotes.length > 0) {
						// Advance by the number of intervals that have passed
						this.currentIndex = (state.index + intervalsPassed) % this.quotes.length;
					} else {
						this.currentIndex = state.index || 0;
					}
				} catch (e) {
					this.currentIndex = 0;
				}
			}
		}

		private saveState(): void {
			localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
				index: this.currentIndex,
				lastUpdate: Date.now()
			}));
		}

		private displayCurrentQuote(): void {
			if (this.quotes.length === 0) return;

			const quote = this.quotes[this.currentIndex];
			const quoteText = document.getElementById('quote-text');
			const quoteAuthor = document.getElementById('quote-author');
			const quoteSourceLink = document.getElementById('quote-source-link') as HTMLAnchorElement;

			if (quoteText && quoteAuthor && quoteSourceLink) {
				// Fade out
				const container = document.getElementById('quote-container');
				if (container) {
					container.classList.add('quote-fade-out');
					
					setTimeout(() => {
						// Update content
						quoteText.textContent = `"${quote.quote}"`;
						quoteAuthor.textContent = `— ${quote.author}`;
						quoteSourceLink.href = quote.source_url;
						quoteSourceLink.title = quote.context;
						
						// Fade in
						container.classList.remove('quote-fade-out');
						container.classList.add('quote-fade-in');
						
						setTimeout(() => {
							container.classList.remove('quote-fade-in');
						}, 500);
					}, 300);
				}
			}

			this.saveState();
		}

		private nextQuote(): void {
			if (this.quotes.length === 0) return;
			this.currentIndex = (this.currentIndex + 1) % this.quotes.length;
			this.displayCurrentQuote();
		}

		private startRotation(): void {
			this.rotationInterval = window.setInterval(() => {
				this.nextQuote();
			}, this.ROTATION_INTERVAL_MS);
		}
	}

	// Initialize quote rotator when DOM is ready
	document.addEventListener('DOMContentLoaded', () => {
		new QuoteRotator();
	});

	// Codeforces API Integration
	interface CodeforcesSubmission {
		id: number;
		contestId: number;
		problem: {
			contestId: number;
			index: string;
			name: string;
			rating?: number;
			tags: string[];
		};
		verdict: string;
		programmingLanguage: string;
	}

	interface CodeforcesResponse {
		status: string;
		result: CodeforcesSubmission[];
		comment?: string;
	}

	// Constants
	const AUTO_REFRESH_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds

	async function fetchSolvedProblems(handle: string): Promise<Set<string>> {
		const response = await fetch(
			`https://codeforces.com/api/user.status?handle=${handle}`
		);
		
		if (!response.ok) {
			throw new Error('Failed to fetch data from Codeforces');
		}
		
		const data: CodeforcesResponse = await response.json();
		
		if (data.status !== 'OK') {
			throw new Error(data.comment || 'User not found');
		}
		
		// Get unique solved problems (verdict = "OK")
		const solvedSet = new Set<string>();
		data.result
			.filter(sub => sub.verdict === 'OK')
			.forEach(sub => {
				const problemId = `${sub.problem.contestId}${sub.problem.index}`;
				solvedSet.add(problemId);
			});
		
		return solvedSet;
	}

	function saveSolvedProblems(handle: string, solved: Set<string>): void {
		localStorage.setItem('cf_handle', handle);
		localStorage.setItem('cf_solved', JSON.stringify(Array.from(solved)));
		localStorage.setItem('cf_last_updated', new Date().toISOString());
	}

	function loadStoredHandle(): string | null {
		return localStorage.getItem('cf_handle');
	}

	function getLastUpdated(): Date | null {
		const timestamp = localStorage.getItem('cf_last_updated');
		return timestamp ? new Date(timestamp) : null;
	}

	function formatTimeAgo(date: Date): string {
		const now = new Date();
		const diffMs = now.getTime() - date.getTime();
		const diffMins = Math.floor(diffMs / 60000);
		const diffHours = Math.floor(diffMs / 3600000);
		const diffDays = Math.floor(diffMs / 86400000);

		if (diffMins < 1) return 'Just now';
		if (diffMins < 60) return `${diffMins}m ago`;
		if (diffHours < 24) return `${diffHours}h ago`;
		return `${diffDays}d ago`;
	}

	function updateSyncTimeDisplay(): void {
		const lastSyncEl = document.getElementById('last-sync');
		const lastUpdated = getLastUpdated();
		
		if (lastSyncEl && lastUpdated) {
			lastSyncEl.textContent = formatTimeAgo(lastUpdated);
			lastSyncEl.title = `Last synced: ${lastUpdated.toLocaleString()}`;
		}
	}

	// Initialize on page load
	document.addEventListener('DOMContentLoaded', () => {
		const input = document.getElementById('cf-handle-input') as HTMLInputElement;
		const button = document.getElementById('track-button') as HTMLButtonElement;
		const syncStatus = document.getElementById('sync-status') as HTMLDivElement;
		const syncButton = document.getElementById('sync-button') as HTMLButtonElement;
		
		// Load stored handle if exists
		const storedHandle = loadStoredHandle();
		if (storedHandle && input) {
			input.value = storedHandle;
			
			// Show sync status if user is already tracked
			if (syncStatus) {
				syncStatus.classList.remove('hidden');
				syncStatus.classList.add('flex');
				updateSyncTimeDisplay();
			}
		}
		
		// Update sync time display every minute
		setInterval(updateSyncTimeDisplay, 60000);

		// Sync function (reusable for both buttons)
		async function syncProgress(showAlert = true): Promise<boolean> {
			const handle = input?.value.trim();
			
			if (!handle) {
				if (showAlert) alert('⚠️ Please enter a Codeforces handle');
				return false;
			}
			
			// Update button states
			button.disabled = true;
			if (syncButton) syncButton.disabled = true;
			
			const originalButtonHTML = button.innerHTML;
			button.innerHTML = '<span class="engineering-button-icon">⏳</span> Syncing...';
			
			// Add spinning animation to sync button
			if (syncButton) {
				syncButton.classList.add('syncing');
			}
			
			try {
				const solvedSet = await fetchSolvedProblems(handle);
				saveSolvedProblems(handle, solvedSet);
				
				// Show success
				button.innerHTML = '<span class="engineering-button-icon">✓</span> Synced!';
				updateSyncTimeDisplay();
				
				// Show sync status if not already visible
				if (syncStatus && syncStatus.classList.contains('hidden')) {
					syncStatus.classList.remove('hidden');
					syncStatus.classList.add('flex');
				}
				
				// Reload page to show updated progress
				setTimeout(() => {
					window.location.reload();
				}, 800);
				
				return true;
				
			} catch (error) {
				console.error('Error fetching Codeforces data:', error);
				if (showAlert) {
					alert(`❌ ${error instanceof Error ? error.message : 'Failed to fetch user data. Please check the handle and try again.'}`);
				}
				button.innerHTML = originalButtonHTML;
				button.disabled = false;
				if (syncButton) {
					syncButton.disabled = false;
					syncButton.classList.remove('syncing');
				}
				return false;
			}
		}
		
		// Handle Track button click
		button?.addEventListener('click', () => syncProgress(true));
		
		// Handle Sync button click
		syncButton?.addEventListener('click', () => syncProgress(true));
		
		// Allow Enter key to submit
		input?.addEventListener('keypress', (e) => {
			if (e.key === 'Enter') {
				syncProgress(true);
			}
		});

		// Auto-refresh when returning to tab after 5+ minutes
		let lastVisibleTime = Date.now();
		
		document.addEventListener('visibilitychange', () => {
			if (document.visibilityState === 'visible') {
				const timeAway = Date.now() - lastVisibleTime;
				const storedHandle = loadStoredHandle();
				
				// If user was away for 5+ minutes and has a tracked handle
				if (timeAway >= AUTO_REFRESH_THRESHOLD && storedHandle) {
					console.log(`Away for ${Math.round(timeAway / 60000)} minutes, auto-syncing...`);
					syncProgress(false); // Silent sync (no alert on error)
				}
			} else {
				lastVisibleTime = Date.now();
			}
		});
	});
</script>

<style>
	@keyframes fade-in {
		from {
			opacity: 0;
			transform: translateY(20px);
		}
		to {
			opacity: 1;
			transform: translateY(0);
		}
	}
	
	.animate-fade-in {
		animation: fade-in 0.8s ease-out;
	}
</style>
